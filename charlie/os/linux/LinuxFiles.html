<!DOCTYPE html>
<html dir="ltr">

<head>
	<meta charset="utf-8" />
	<title>LinuxFiles</title>
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<link rel="shortcut icon" href="/charlie/images/favicon.png">
	<!-- Latest compiled and minified CSS -->
	<link rel="stylesheet" href="//netdna.bootstrapcdn.com/bootstrap/3.0.0/css/bootstrap.min.css">
	<!-- Optional theme -->
	<link rel="stylesheet" href="//netdna.bootstrapcdn.com/bootstrap/3.0.0/css/bootstrap-theme.min.css">
	<link href="/charlie/libs/css/BootstrapIndex.css" rel="stylesheet" type="text/css" />
	<!-- Latest compiled and minified JavaScript - Move to bottom of body element -->
	<script src="//code.jquery.com/jquery.js"></script>
	<script src="//netdna.bootstrapcdn.com/bootstrap/3.0.0/js/bootstrap.min.js"></script>
	<script src="/charlie/libs/scripts/elvenware.js" type="text/javascript"></script>
	<script type="text/javascript">
		var _gaq = _gaq || [];
		_gaq.push(['_setAccount', 'UA-2806409-2']);
		_gaq.push(['_trackPageview']);
		(function() {
			var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
			ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
			var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
		})();
	</script>
</head>

<body>



	<!-- removed  navbar-fixed-top -->
	<div class="navbar navbar-inverse">
		<div class="container">
			<div class="navbar-header">
				<button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
					<span class="icon-bar"> </span>
					<span class="icon-bar"> </span>
					<span class="icon-bar"> </span>
				</button>
				<a class="navbar-brand" href="/charlie/index.html">Elvenware</a>
			</div>
			<div class="collapse navbar-collapse">
				<ul class="nav navbar-nav">
					<li class="active"><a href="/charlie/index.html">Home</a></li>
					<li><a href="/charlie/contents.html">About</a></li>
					<li class="dropdown">
						<a href="#" class="dropdown-toggle" data-toggle="dropdown">Dropdown <b class="caret"></b></a>
						<ul class="dropdown-menu">
							<li class="dropdown-header">Core Code</li>
							<li><a href="/charlie/development/index.html">Strongly Typed</a></li>
							<li><a href="/charlie/development/web/index.html">Web &amp; Scripts</a></li>
							<li><a href="/charlie/development/cloud/index.shtml">Cloud</a></li>
							<li class="divider"></li>
							<li class="dropdown-header">OS and Tools</li>
							<li><a href="/charlie/os/index.html">OS</a></li>
							<li><a href="/charlie/development/database/index.html">Database</a></li>
							<li><a href="/charlie/books/index.html">My Writing</a></li>
							<li class="divider"></li>
							<li class="dropdown-header">Art</li>
							<li><a href="/charlie/Art/index.html">Poems &amp; Photos</a></li>
							<li><a href="/charlie/books/reading/index.html">Book Reviews</a></li>
							<li><a href="/charlie/spirit/index.html">Spiritual</a></li>
							<li class="divider"></li>
							<li class="dropdown-header">Links</li>
							<li><a href="/charlie/links.html">My Links</a></li>
							<li><a href="http://www.github.com/charliecalvert">GitHub</a></li>
							<li><a href="http://sourceforge.net/projects/elvenware/">Sourceforge</a></li>
						</ul>
					</li>
				</ul>
			</div><!--/.nav-collapse -->
		</div>
	</div>

	<div class="container">

		<div class="starter-template">
			<figure><img alt="Elvenware" src="/charlie/images/elvenwarelogo.png" /></figure>
<h2>Table of Contents</h2>
<ul class="elfTocHeading">
	<li><a href='#working-with-files-in-linux-and-os-x'>Working with Files in Linux (and OS X)</a></li>
	<li><a href='#overview'>Overview</a></li>
	<li><a href='#fileOverview'>File Permission Overview</a></li>
	<li><a href='#home'>Where is my Home Directory?</a></li>
	<li><a href='#listing-files-with-ls'>Listing Files with ls</a></li>
	<li><a href='#pwd'>Change or Check Your Current Location: CD and PWD</a></li>
	<li><a href='#copy'>Copying or Moving Files</a></li>
	<li><a href='#more-examples'>More Examples</a></li>
	<li><a href='#nano-editor'>Nano Editor</a></li>
	<li><a href='#vim-editor'>Vim Editor</a></li>
</ul>
<h1 id="working-with-files-in-linux-and-os-x">Working with Files in Linux (and OS X)</h1>
<p>In this page we explore performing basic file operations in Linux from the command line (shell). The information you find here is geared towards the Ubuntu family of releases, such as Ubuntu desktop, Ubuntu server, Lubuntu, and the various Mint Linux flavors.</p>
<p>I should point out that the Mac also has a Unix style command prompt. As a result, most of what I say here applies to a greater or lesser degree to OS X. There are differences, however, between the Ubuntu Linux command prompt and the Mac command prompt. I would suggest reading through this text and mastering the Linux command prompt. Once you feel comfortable with these commands, then start trying them on the Mac. Most of them will work exactly as shown here. The variations, as a rule, are easy to discover once you understand what it is you are trying to do. For instance, on the Mac, the home directory is in the <strong>/user/</strong>folder, while on Linux it is in the<strong>/home</strong> folder. Yes there is a difference, but it is not an important difference. Or at least I personally don't find it significant.</p>
<p>What is significant, however, is that Linux is the most popular operating system in the cloud, and OS X is the popular system of under 30 types in the US. As a result, it can be very useful to begin to understand how the Linux or Mac command line (shell) works.</p>
<h2 id="overview">Overview</h2>
<p>This page is designed to help new comers to Linux use the basic commands needed to create, move and edit files are on the command line. The following commands are covered:</p>
<ol type="1">
<li>ls: List the contents of a directory</li>
<li>cd: Change directory</li>
<li>pwd: Print my current working directory</li>
<li>cp: Copy a file</li>
<li>mv: Move a file</li>
<li>rm: Delete (remove) a file</li>
<li>mkdir: Create a directory</li>
<li>rmdir: Delete a directory</li>
<li>sudo: When do I need to use sudo when working with files?</li>
<li>chmod: Change the file mode so you can read, write or execute a file</li>
<li>chown: Change the user and/or group that owns a file</li>
<li>fs: How much free space is available on my drive?</li>
</ol>
<p>In addition, I will briefly discuss the following text editors: nano, vim, gedit and leafpad: This is not the place to learn how to use these editors, but it is a good place to explain which of these editors you might want to use and why.</p>
<p>The dozen core commands listed above give you the power you need to master Linux file system. You may be asking yourself: &quot;Do I have to know all these commands.&quot; In many cases, the answers is no. You might also ask: &quot;Is this an exhaustive list?&quot; Again, the answer is no. I am trying to employ a variation of the 80-20 rule here. These are the core commands that most users need to most of the time. Ninety eight percent of the time these twelve rules provide all the power you need. (The one possible exception involves search for <a href="http://www.elvenware.com/charlie/os/linux/LinuxDays/LinuxFAQ.html#grep">text with grep</a> or <a href="http://www.elvenware.com/charlie/os/linux/LinuxDays/LinuxFAQ.html#finddir">files with find</a>. Those subjects are covered elsewhere.</p>
<p>I have tried to arrange the commands listed above in some kind of reasonable order, from basic to esoteric. Some users may only need to know the first command, and many users could get by with a knowledge of only the first 6 or seven commands. After all, if you know how to copy and move files, and you know how to create and delete directories, you have a pretty good command of your system.</p>
<p>If however, you want to act as a system administrator who performs basic configuration steps on your system, then you may need to know all these commands. Getting a grasp of all of them requires more than a few minutes work, but it is not a particularly difficult job. For instance, if you know how to edit HTML files by hand, or write a beginning level computer program, then you will find the task of mastering the basics of the commands listed above to be relatively trivial.</p>
<h2 id="fileOverview">File Permission Overview</h2>
<p>In Linux, as in Windows, by default there are folders where you have permission to manipulate files and other folders where you do not have permissions. The rule that governs this issue is fairly easy to understand:</p>
<ul>
<li>You have permission to edit all the files in your home directory.</li>
<li>Only the administrator (who is called root) has permission to edit the rest of the files on your system.</li>
</ul>
<p>In Windows, the situation is much the same. You have permission to edit the files in your My Documents directory, and in your home directory. But if you go into the Program Files directory, or the Windows directory, then you usually have to become administrator before you can edtit a file.</p>
<p>In Windows, a feature called UAC (User Access Control) enforces this rule. In Linux, a command called <strong>sudo</strong> is used to give you permission to edit files outside your home directory. That is, it gives you permission to temporarily become an administrator (super user) and manage files owned by the system, or by other users. For now, I just want to be sure you understand that you can edit files outside your home directory, and that you use the <strong>sudo</strong> command to gain permission to do so. The details of how that works will be discussed later in this document.</p>
<p>NOTE: On Linux systems there is a user called <strong>root</strong> who has super user (administrator) permissions. If you want to edit, rename or delete a file owned by root then you need to use the <strong>sudo</strong> command to gain permission to do so. If you are in a directory owned by root, then you need to use <strong>sudo</strong> to copy files into that directory. The exact mechanism for doing these things will be explained later in this document.</p>
<h2 id="home">Where is my Home Directory?</h2>
<p>Knowing that you have permission to edit files in your home directory is all well and good, but where, exactly is your home directory? Your home directory is located here:</p>
<pre><code>/home/$USER</code></pre>
<p>For instance, if my user names is charlie, then my home directory would be located here:</p>
<pre><code>/home/charlie</code></pre>
<p>This seems fairly straightforward, but there is a little twist that Linux throws at you herer. When first arrive at the command prompt (shell) for your Linux box, you usually see something like this:</p>
<pre><code>charlie@MyServer:~$</code></pre>
<p>This prompt tells me that I am logged on to the machine called <strong>MyServer</strong> as the user <strong>charlie</strong> and that I am currently located in my home directory. If you study the prompt shown above, you probably find it fairly easy to see the bit about being logged into a particular server as a particular user. But how do you know you are in your home directory? You can glean that information for the ~$ symbol. In particular, the tilde (~) is an alias for your home directory, and the $ is simply the symbol that tells you are at the root of the prompt.</p>
<p>You are probably familiar with the syntax of the Windows command prompt. Consider the following prompt, which shows my home directory:</p>
<pre><code>C:\Users\Charlie&gt;</code></pre>
<p>The greater than symbol (&gt;) at the Windows prompt plays the same role as the dollar sign symbol ($) at the Linux prompt. It just tells you that this is the beginning of the location where you can start typing in commands. It is the beginning, or root, of the command prompt:</p>
<pre><code>charlie@MyServer:~$
C:\Users\Charlie&gt;</code></pre>
<p>Despite all this explanation, there is probably still something that does not quite make sense to you. What does it mean to say that the ~ symbol is an alias for the home directory. On Windows, we know from the prompt that the home directory is <strong>C:\Users\Charlie</strong>. In Linux, however, all we know is that the ~ symbol resolves to the home directory. Above, I explained that the home directory for the user <strong>charlie</strong> is located here:</p>
<p>/home/charlie</p>
<p>So, why doesn't the prompt just tell us that? Why can't Linux be more direct? The answer is simply that Linux doesn't want to waste your time pointing out the obvious. Unless the prompt specifically says otherwise, you can just assume that you are in your home directory. After all, that is where you spend more of your time. If you move to the bin directory, or etc directory, then the prompt tells you that. Otherwise, it just gives you the tilda (~) as a little reminder that you are still where you have been all day long: you home directory.</p>
<p>Here, for instance, is what it looks like if you have navigated to the etc directory:</p>
<p>charlie@MyServer:<strong>/etc$</strong></p>
<p>Notice that that there is no tilde in the prompt. That means you are no longer in your home directory.</p>
<h2 id="listing-files-with-ls">Listing Files with ls</h2>
<p>You can use the list command to list the files in a directory. Suppose you are in your home directory. Suppose further that it contains two subdirectories called Documents and Pictures, and a text file called <strong>readme.txt</strong>:</p>
<pre><code>/home/charlie
-- Documents
-- Pictures
-- readme.txt</code></pre>
<p>You can see the files in your directory by type the <strong>ls</strong> command.</p>
<pre><code>charlie@ShantiLinuxServer:~$ ls
Documents  Pictures  readme.txt</code></pre>
<p>The dir command also performs the same task, though in the Linux world, <strong>ls</strong> is more commonly used:</p>
<pre><code>charlie@ShantiLinuxServer:~$ dir
Documents  Pictures  readme.txt</code></pre>
<p>You can get a long listing of the files with <strong>ls -l</strong> or <strong>dir -l</strong>. That would be the letters L and S followed by a space, then the a dash, then the letter L, all in lower case:</p>
<pre><code>charlie@ShantiLinuxServer:~$ ls -l
total 12
drwxrwxr-x 2 charlie charlie 4096 Jan 31 19:46 Documents
drwxrwxr-x 2 charlie charlie 4096 Jan 31 19:46 Pictures
-rw-rw-r-- 1 charlie charlie   21 Jan 31 19:47 readme.txt</code></pre>
<p>The ls command reports that there are total of 12 files in this current directory. Three of them are visible, and 9 are hidden. We will see how to view the hidden files in just a moment. But for now, let's focus on the 3 files we can see.</p>
<p>Starting on the left, we can see 6 groups of information:</p>
<ol type="1">
<li><strong>drwxrwxr-x</strong>: The file or directory permissions</li>
<li><strong>2</strong>: The number of directories. More on this in a moment.</li>
<li><strong>charlie charlie</strong>: The owner of the directory or file, and the group to which it belongs</li>
<li><strong>4096</strong>: The size of the file or directory block in bytes</li>
<li><strong>Jan 31 19:46</strong>: The date. Because no year is listed, we can assume it was created in the current year</li>
<li><strong>Documents</strong>: The name of the directory or file</li>
</ol>
<p>The file permissions are always confusing to people who are new to Linux. The topic is actually quite a bit simpler than it seems at first glance. The following table may help you get oriented:</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">Description</th>
<th style="text-align: left;">Abbreviation</th>
<th style="text-align: left;">Code</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">Execute</td>
<td style="text-align: left;">x</td>
<td style="text-align: left;">1</td>
</tr>
<tr class="even">
<td style="text-align: left;">Write</td>
<td style="text-align: left;">w</td>
<td style="text-align: left;">2</td>
</tr>
<tr class="odd">
<td style="text-align: left;">Read</td>
<td style="text-align: left;">r</td>
<td style="text-align: left;">4</td>
</tr>
<tr class="even">
<td style="text-align: left;">Read and Execute</td>
<td style="text-align: left;">rx</td>
<td style="text-align: left;">5</td>
</tr>
<tr class="odd">
<td style="text-align: left;">Read and Write</td>
<td style="text-align: left;">rw</td>
<td style="text-align: left;">6</td>
</tr>
<tr class="even">
<td style="text-align: left;">Read, Write &amp; Execute</td>
<td style="text-align: left;">rwx</td>
<td style="text-align: left;">7</td>
</tr>
</tbody>
</table>
<p>For now, you should just focus on the Description and Abbreviation fields of the above table. The Code plays a useful role, but we need not wrestle with that quite yet.</p>
<p>Here are the positions of the flags for the various people who may attempt to use the file. The first position is set to d if it is a directory, or - if it is a file. The next three positions apply to the owner of the file, the next three to the group, and the last three to everyone else. If you are a member of the group that has read, write and execute permissions on a file, then you can read, write and execute the file. Here is the table:</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">Name</th>
<th style="text-align: left;">Location</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">directory</td>
<td style="text-align: left;">d---------</td>
</tr>
<tr class="even">
<td style="text-align: left;">owner</td>
<td style="text-align: left;">-rwx------</td>
</tr>
<tr class="odd">
<td style="text-align: left;">group</td>
<td style="text-align: left;">----rwx---</td>
</tr>
<tr class="even">
<td style="text-align: left;">other</td>
<td style="text-align: left;">-------rwx</td>
</tr>
</tbody>
</table>
<p>Sometimes people prefer to present the same information in this format:</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">Position</th>
<th style="text-align: left;">Meaning</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">1</td>
<td style="text-align: left;">Usually either d for directory or - for normal.</td>
</tr>
<tr class="even">
<td style="text-align: left;">2,3,4</td>
<td style="text-align: left;">The owner's read, write and execute permissions</td>
</tr>
<tr class="odd">
<td style="text-align: left;">5,6,7</td>
<td style="text-align: left;">The group's read, write and execute permissions</td>
</tr>
<tr class="even">
<td style="text-align: left;">8,9,10</td>
<td style="text-align: left;">Everyone else's read, write and execute permissions</td>
</tr>
</tbody>
</table>
<p>Here are the values of the flags themselves:</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">Flag</th>
<th style="text-align: left;">Meaning</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">-</td>
<td style="text-align: left;">There is no value for this space. It is blank.</td>
</tr>
<tr class="even">
<td style="text-align: left;">r</td>
<td style="text-align: left;">Read rights on the file</td>
</tr>
<tr class="odd">
<td style="text-align: left;">w</td>
<td style="text-align: left;">Write permission to edit or delete.</td>
</tr>
<tr class="even">
<td style="text-align: left;">x</td>
<td style="text-align: left;">Rights to execute or list the files in a directory</td>
</tr>
<tr class="odd">
<td style="text-align: left;">s</td>
<td style="text-align: left;">Special set-UID or set-groupID flag. Rare. Ignore for now.</td>
</tr>
</tbody>
</table>
<p>Let's look at the permissions for Documents:</p>
<pre class="code"><code>drwxrwxr-x</code></pre>
<p>The d at the beginning means that this is a directory. Compare those permissions with the permissions for <strong>readme.txt</strong>:</p>
<pre class="code"><code>-rw-rw-r--</code></pre>
<p>In this second example, the first space is empty. As a result, we can assume that <strong>readme.txt</strong> is not a directory, but a regular file. Conversely, we know that Documents is a directory because there is a d in the first position of its permissions flags.</p>
<p>After the d in the permissions block for the Documents directory there are three sets of letters:</p>
<pre class="code"><code>d rwx rwx r-x</code></pre>
<p>The first set of three letters mean that the owner of the file (<strong>charlie</strong>) has read, write and execute permissions on the directory. The second block of 3 letters mean that any member of the group <strong>charlie</strong> has read write and execute permissions on the directory. The final three letters mean that any one else has read and execute permissions, but no write permissions. In effect, this means that everyone beside the owner and the members of the group <strong>charlie</strong> can read the name of the directory, and they can navigate into it, but the can't delete or rename it.</p>
<p>Now let's look at the permissions for <strong>readme.txt</strong>:</p>
<pre class="code"><code>-rw-rw-r--</code></pre>
<p>We see from the blank first letter that this is a normal file, and not a directory. The next three letters apply to the <strong>owner</strong>, who in this case is <strong>charlie</strong>:</p>
<pre class="code"><code>rw-</code></pre>
<p>We can see that <strong>charlie</strong> has read and write permissions on this file, but no execute permissions. The lack of execute permissions is not really a statement about the range of control that <strong>charlie</strong> has over the file so much as a statement about the capabilities of the file. This is a text file that is meant to be read, and so it would not make sense to try to execute it. Sometimes, we explicitly do not give the owner, group or others the permission to execute a file that is meant to be executed. But in this case, it is not really permissions that are at stake. This is simply an implied, and rather oblique, comment about the file itself.</p>
<p><strong>NOTE</strong>: It is perfectly legal to set execute permissions for a file that contains simple text, and no code. For instance, you can set the execute flag for readme.txt, even though any effort to execute it would fail since it does not contain executable code. In other words, it contains simple text, and has no code, in either binary or text format, associated with it. It is therefore correct to say that it would not be sensible to set the execute flag for <strong>readme.txt</strong>, but it would not be illegal. Typically Linux files that can be executed either have a <strong>.sh</strong> extension, or else they have no extension at all. For instance, a file called <strong>RunMe.sh</strong> or <strong>RunMe</strong> might be possible to execute, so long as the execute permissions are set on the file itself:</p>
<pre class="code"><code>-rwxrw-r-x 1 charlie charlie 4 Feb 1 01:05 RunMe.sh</code></pre>
<p>Let's continue our discussion of <strong>readme.txt</strong>. We can see that members of the group <strong>charlie</strong> also have read and write permissions, but no execute permissions:</p>
<pre class="code"><code>rw-</code></pre>
<p>Finally, we can see that everyone else can read the file, but not edit it or delete it, nor can than they execute it:</p>
<pre class="code"><code>r--</code></pre>
<p>That's all I'm going to say for now about the permissions section of the long listing for directory or file.</p>
<p>Scan back up to the original listing, and you will see that second item in second item in the row for the Documents and Pictures directory contains the number 2, which I say refers to the number of directories. What does that mean? In this case, both the Documents and Pictures directory are empty. As a result, the are recorded as containing both themselves and their parent directory. These would typically be shown as a directory called . (a period) and a directory called .. (two periods). Here is an example:</p>
<pre class="code"><code>charlie@ShantiLinuxServer:~/Documents$ ls -la
total 8
drwxrwxr-x 2 charlie charlie 4096 Jan 31 19:46 .
drwxr-xr-x 6 charlie charlie 4096 Jan 31 19:50 ..</code></pre>
<p>Both of these directories are normally hidden because they begin with a period. To see the hidden directories in our home folder, we use the ls -la command:</p>
<pre class="code"><code>charlie@ShantiLinuxServer:~$ ls -la
total 48
drwxr-xr-x 6 charlie charlie 4096 Jan 31 19:50 .
drwxr-xr-x 3 root    root    4096 Jan 30 17:15 ..
-rw------- 1 charlie charlie  477 Jan 31 19:54 .bash_history
-rw-r--r-- 1 charlie charlie  220 Jan 30 17:15 .bash_logout
-rw-r--r-- 1 charlie charlie 3637 Jan 30 17:15 .bashrc
drwx------ 2 charlie charlie 4096 Jan 30 17:50 .cache
drwxrwxr-x 2 charlie charlie 4096 Jan 31 19:46 Documents
drwxrwxr-x 2 charlie charlie 4096 Jan 31 19:46 Pictures
-rw-r--r-- 1 charlie charlie  675 Jan 30 17:15 .profile
-rw-rw-r-- 1 charlie charlie   21 Jan 31 19:47 readme.txt
drwx------ 2 charlie charlie 4096 Jan 31 19:54 .ssh
-rw------- 1 charlie charlie  608 Jan 31 19:47 .viminfo</code></pre>
<p>In this listing, our familiar <strong>Documents</strong>, <strong>Pictures</strong> and <strong>readme.txt</strong> items are still visible. We now also see a series of hidden files or folders, each of which begin with a period. The period character is used to create a hidden file or folder. In general, we hide the files not to protect them, but simply to keep them out of the way when the user is pursuing his normal course of work. Most of the time, the user does not need to see all these files or folders, so they are hidden away where they will not clutter the landscape.</p>
<h2 id="pwd">Change or Check Your Current Location: CD and PWD</h2>
<p>Despite all that is said above, you might still want some confirmation as to the name of your current directory. Use the PWD command (Print Working Directory) to always be sure you know your current location. In the following code, I use pwd to navigate to the log directory from the home directory:</p>
<pre class="code"><code>charlie@MyServer:~$ pwd
/home/ubuntu
charlie@MyServer:~$ cd /var/log/
charlie@MyServer:~$:/var/log$ pwd
/var/log</code></pre>
<p>In the code above, the prompt is in plain text. The commands and output from the commands are shown in bold.</p>
<p>The first command issued at the shell prompt is <strong>pwd</strong>. To issue the command, just type <strong>pwd</strong> and hit enter. This prints the working directory. The output is <strong>/home/ubuntu</strong>, which is my home folder on this machine.</p>
<p>I then navigate to the <strong>/var/log</strong> folder with the <strong>cd</strong>, or change directory command. I then call <strong>pwd</strong> to print out the current directory. The output produced is <strong>/var/log</strong>. If you want, you can now optionally type <strong>cat boot.log</strong> to see the output of your boot log. (On Windows, the command to view the contents of a file is <strong>type filename</strong>. In Linux, it is <strong>cat filename</strong>, where catalogue is a mnemonic for print out.</p>
<p>Since many users first need to understand the file system when working with a web site, I will give another example that uses the /var/www folder. This directory will not exist unless you have installed apache. If you don't have apache installed on your system, you can just ignore this section of the text, and move on to the discussion of copying files.</p>
<p>If you are still here, then you will find the following code, I use pwd to check my location, I navigate to to the <strong>/var/www/</strong> directory, I create a directory called temp, I copy files into it.</p>
<pre class="code"><code>ubuntu@domU-12-31-39-14-16-01:~$ pwd
/home/ubuntu
ubuntu@domU-12-33-37-17-14-01:~$ cd /var/www/
ubuntu@domU-12-33-37-17-14-01:/var/www$ pwd
/var/www
ubuntu@domU-12-33-37-17-14-01:/var/www$ sudo mkdir temp
ubuntu@domU-12-33-37-17-14-01:/var/www$ cd temp
ubuntu@domU-12-33-37-17-14-01:/var/www/temp$ pwd
/var/www/temp
ubuntu@domU-12-33-37-17-14-01:/var/www/temp$ sudo cp /home/ubuntu/* .
ubuntu@domU-12-33-37-17-14-01:/var/www/temp$ ls -la
total 296
drwxr-xr-x 2 root root 4096 Oct 24 02:24 .
drwxr-xr-x 3 root root 4096 Oct 24 02:24 ..
-rw-r--r-- 1 root root 3103 Oct 24 02:24 Buttons.css
-rw-r--r-- 1 root root 2418 Oct 24 02:24 Twitter.js
-rw-r--r-- 1 root root 756 Oct 24 02:24 TwitterQuery.html
ubuntu@domU-12-33-37-17-14-01:/var/www/temp$</code></pre>
<p>One of the lessons to be learned from the above is that the pattern ~$ references your home directory.</p>
<h2 id="copy">Copying or Moving Files</h2>
<p>Here is how to copy a file into a a particular directory:</p>
<pre class="code"><code>cp MyFile.txt MyDirectory/.</code></pre>
<p>This command copies the file called <strong>MyFile.txt</strong> into the folder called <strong>MyDirectory</strong>. The slash and dot at the end of the command say that you are supposed to put the file that is being copied in the position of the dot:</p>
<pre class="code"><code>MyDirectory/MyFile.txt</code></pre>
<p>Here is how to move the file called <strong>MyFile.tx</strong>t from its current position to <strong>MyDirectory</strong>:</p>
<pre><code>mv MyFile.txt MyDirectory/.</code></pre>
<p>Here is how to copy a file called <strong>MyPicture.png</strong> from the <strong>Documents</strong> directory to the <strong>Pictures</strong> directory:</p>
<pre class="code"><code>cp Documents/MyPicture.png Pictures/.</code></pre>
<p>Note that when you give commands like this, they will only give you feedback if they fail. If the command succeeds, it succeeds silently:</p>
<pre class="code"><code>charlie@ShantiLinuxServer:~$ cp /home/charlie/Documents/MyPicture.png Pictures/.
charlie@ShantiLinuxServer:~$</code></pre>
<p>Notice that there is no text at all at the prompt that appears after the command executes. That means that you command succeeded.</p>
<p>Here is what you see if you try to copy a file that does not exist. Note that in this case we see an error:</p>
<pre class="code"><code>charlie@ShantiLinuxServer:~$ cp Documents/FooBar.png Pictures/.
cp: cannot stat `Documents/FooBar.png&#39;: No such file or directory</code></pre>
<p>The cryptic words &quot;cannot stat&quot; means that the system cannot find your file and report its status.</p>
<p>The following command will rename the file <strong>RunMy.sh</strong> to <strong>RunMe.sh</strong>:</p>
<pre class="code"><code>mv RunMy.sh RunMe.sh</code></pre>
<p>Note that we have used the move (mv) command to rename the file. This is common practice in Linux.</p>
<h2 id="more-examples">More Examples</h2>
<p>This example below shows how to copy files from your home directory to the <strong>/r/www</strong> directory. In particular, we are going to copy three files called <strong>index.html</strong>, <strong>index.css</strong> and <strong>index.js</strong> to that directory. In our example, <strong>index.html</strong> links in both <strong>index.css</strong> and <strong>index.js</strong>.</p>
<p><strong>NOTE</strong>: <em>I'm working on a local Linux box called</em><strong><em>MountainPass</em></strong><em>. It is an instance of Ubuntu desktop 12.04. My user name is</em><strong><em>charlie</em></strong><em>. So every time you see me write</em><strong><em>charlie</em></strong><em>, you would write or see your user name. For instance, if you are on a default EC2 instance, you would write or see</em><strong><em>ubuntu</em></strong><em>instead of</em><strong><em>charlie.</em></strong></p>
<p>Let's suppose you have used <a href="/charlie/development/cloud/SshFtpsPutty.html#filezilla">Filezilla</a> to copy files to a directory called <strong>Prog270</strong> located on a Linux machine. Suppose further that the directory is a sub-directory of your home directory. We can check our current location using PWD:</p>
<pre class="code"><code>charlie@MountainPass:~/Prog270$ pwd
/home/charlie/Prog270</code></pre>
<p>Let's get a listing of the files in the directory:</p>
<pre class="code"><code>charlie@MountainPass:~/Prog270$ ls
index.css index.html index.js</code></pre>
<p>As you can see, the Prog270 directory contains three files called <strong>index.css</strong>, <strong>index.html</strong> and <strong>index.js</strong>. Let's see what files are currently in the <strong>/var/www/</strong> directory:</p>
<pre class="code"><code>charlie@MountainPass:~/Prog270$ ls /var/www
index.html</code></pre>
<p>At this time there is only one file in <strong>/var/www.</strong> It is called <strong>index.html</strong>. That file was put there as a default home page during the install of the Apache web server. Our goal is to copy our three files to the <strong>/var/www</strong> directory. When we are done, the original default instance of <strong>index.html</strong> will be replaced with our new copy of the file. We should also see <strong>index.css</strong> and <strong>index.js</strong> in the <strong>/var/www</strong> directory.</p>
<p>Let's use the Linux <strong>sudo</strong> and <strong>cp</strong> commands to copy our files to the <strong>/var/www</strong> directory:</p>
<pre class="code"><code>charlie@MountainPass:~/Prog270$ sudo cp * /var/www/.
charlie@MountainPass:~/Prog270$</code></pre>
<p>We need to use the <strong>sudo</strong> command because the <strong>/var/www</strong> directory is owned by <strong>root</strong>, and the user <strong>charlie</strong>does not have permissions to write to that directly. The sudo command allows us to &quot;do&quot; something as the <strong>su</strong>, or superuser. In other words, it lets us become root for a short time. The <strong>cp</strong>, command, of course, is the Linux command for copying files. The end result of using the two commands together is to copy the files from the <strong>Prog270</strong> directory to the <strong>/var/www</strong> directory.</p>
<p>Let's take a look at the state of the <strong>/var/www</strong> directory after the copy:</p>
<pre class="code"><code>charlie@MountainPass:~/Prog270$ ls /var/www
index.css index.html index.js</code></pre>
<p>As you can see, we have successfully copied the files <strong>index.css</strong>, <strong>index.html</strong> and <strong>index.js</strong> to the <strong>/var/www</strong> directory. In this process we intentionally overwrote the original copy of <strong>/var/www/index.html</strong> with the new version of the file that we copied from <strong>/home/charlie/Prog270</strong>. This was our goal, and so our task is done. If Apache is set up right, and Port 80 is open, we can now go to a web browser, point it at our Linux box, and see our new copy of <strong>index.html</strong>. If we examine that file, we should find that it links <strong>index.css</strong> and <strong>index.js</strong>.</p>
<h2 id="nano-editor">Nano Editor</h2>
<p>Nano is an editor available at the Linux command prompt. It is fairly easy to use, but not as popular as vim. Or at least it does not attract as fanatical a following.</p>
<p>To use nano you must understand at least two commands. Don't try to save a file Ctrl-S, instead, use Ctrl-O. When you want to exit, use Ctrl-X. Though not essential, it is also good to know how to get help. The help command is Ctrl-G.</p>
<ul>
<li><strong>Save</strong>: Ctrl-0</li>
<li><strong>Exit</strong>: Ctrl-X</li>
<li><strong>Help</strong>: Ctrl-G</li>
</ul>
<p>Navigation:</p>
<ul>
<li><strong>Previous Line</strong>: Ctrl-P</li>
<li><strong>Next Line</strong>: Ctrl-N</li>
<li><strong>Advance One Character</strong>: Ctrl-F</li>
<li><strong>Back One Character</strong>: Ctrl-B</li>
<li><strong>Search</strong>: Ctrl-W</li>
</ul>
<p>That's enought to allow you to do some reasonably productive work. If you want to know more, there are a number of guides to using nano and its shortcuts. Try these searches:</p>
<ul>
<li><a href="http://www.google.com/search?q=nano%20shortcuts">nano shortcuts</a></li>
<li><a href="http://www.google.com/search?q=nano%20editor%20get%20started">nano editor get started</a></li>
</ul>
<h2 id="vim-editor">Vim Editor</h2>
<p>The VIM editor is designed to drive Windows users completely buggy. I have no idea why it is so popular, but it is popular, and it is well maintained. It is supported on all platforms.</p>
<p>We usually use vim at the command line and start it with the command vim. In some cases you should use vi instead of vim. There are solid GUI based versions of VIM for both Windows and Linux.</p>
<p>The key thing you need to grasp about Vim is that there are two entirely different modes:</p>
<ul>
<li>Insert Mode (Press i or o)</li>
<li>Command Mode (Press Esc)</li>
</ul>
<p>It is, frankly, a huge hurtle for most users to jump over. However, you can get used to vim if you make an effort. The actual act of learning vim is not as hard as getting over the hurtle of grasping how it works.</p>
<p>To get started, press i to enter INSERT mode. Start typing. Using the arrow, home and end keys to navigate. When you want to save the file, first press escape, then :w. If you want to quit, then press :q. If you want to both save and quit, then press :wq.</p>
<p>There are many, many guides to using vim and its shortcuts. Try these searches:</p>
<ul>
<li><a href="http://www.google.com/search?q=vim%20shortcuts">vim shortcuts</a></li>
<li><a href="http://www.google.com/search?q=vim%20get%20started">vim get started</a></li>
</ul>
<!-- FOOTER -->
      <footer>
        <p class="pull-right"><a href="#">Back to top</a></p>        
		<p>Copyright &copy; <a href="/charlie/index.html">Charlie Calvert</a> |
		<a href="/charlie/contents.html">Site Overview</a> |
		<a href="/charlie/development/index.html">Writing Code</a> |
		<a href="/charlie/development/web/index.html">Web</a> |
		<a href="/charlie/development/web/JavaScript/index.html">JavaScript</a> |
		<a href="/charlie/books/index.html">My Books</a> </p>

      </footer>

    </div><!-- /.container -->
</body>
</html>



